"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NativeLogCollector = void 0;
const heap_js_1 = require("heap-js");
const common_1 = require("@temporalio/common");
const logger_1 = require("./logger");
/**
 * A log collector that accepts log entries either through the TS `Logger` interface (e.g. used by
 * the Worker, and backing Workflows and Activities Context logging) or by pushing from the native
 * layer. Logs are buffered for a short period of time, then sorted and emitted to a downstream
 * logger, in the right order.
 *
 * @internal
 * @hidden
 */
class NativeLogCollector {
    /**
     * The Logger instance ti be used to send logs to this collector
     */
    logger;
    /**
     * The downstream logger to which this collector reemits logs.
     */
    downstream;
    buffer = new heap_js_1.Heap((a, b) => Number(a.timestampNanos - b.timestampNanos));
    constructor(downstream) {
        this.logger = new logger_1.DefaultLogger('TRACE', (entry) => this.buffer.add(entry));
        this.downstream = downstream;
        this.receive = this.receive.bind(this);
    }
    /**
     * Accept logs pushed from the native layer.
     *
     * Called from the native layer; this function is not allowed to throw.
     */
    receive(entries) {
        try {
            for (const entry of entries) {
                const log = this.convertFromNativeLogEntry(entry);
                if (log) {
                    this.buffer.add(log);
                }
            }
            this.flush();
        }
        catch (_e) {
            // We're not allowed to throw from here, and conversion errors have already been handled in
            // convertFromNativeLogEntry(), so an error at this point almost certainly indicates a problem
            // with the downstream logger. Just swallow it, there's really nothing else we can do.
        }
    }
    convertFromNativeLogEntry(entry) {
        try {
            const log = JSON.parse(entry);
            const timestampNanos = BigInt(log.timestamp);
            return {
                message: log.message,
                timestampNanos,
                level: log.level,
                meta: {
                    [logger_1.LogTimestamp]: timestampNanos,
                    sdkComponent: common_1.SdkComponent.core,
                    target: log.target,
                    spanContexts: log.spanContexts,
                    ...log.fields,
                },
            };
        }
        catch (e) {
            this.downstream.error(`Error converting native log entry: ${e}`, {
                error: e,
                entry,
            });
            return undefined;
        }
    }
    /**
     * Flush all buffered logs into the logger supplied to the constructor/
     */
    flush() {
        for (const entry of this.buffer) {
            this.downstream.log(entry.level, entry.message, {
                [logger_1.LogTimestamp]: entry.timestampNanos,
                ...entry.meta,
            });
        }
        this.buffer.clear();
    }
}
exports.NativeLogCollector = NativeLogCollector;
//# sourceMappingURL=runtime-logger.js.map